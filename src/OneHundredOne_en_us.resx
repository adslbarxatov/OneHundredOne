<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="HelpText" xml:space="preserve">
    <value>“One hundred and one” game

A pack of 36 cards is used. Each player is dealt 4 cards. The last card dealt is placed on the table next to the remaining pack (i.e. the dealer makes the first turn). The next player covers this card with one or more of the cards he has, depending on the situation (see below). If there are no options, player can take one additional card from the pack. If there are still no options, the player skips the turn.

Each next player does the same. If the cards in hand run out, the player is out of the round. The round ends when there is only one person left at the table who has cards in his hand. For a game of two, the exit of one player coincides with the end of the round.

The player’s penalty points are counted on the remaining cards. Also, according to the cards with which the other players completed the round, their bonuses are determined. As a result, if someone’s points exceed 101, he is considered a loser. If a player gets exactly 101 points, his penalty is reset to zero.

There are three ways to cover any card:
— a card of the same suit;
— a card of the same denomination;
— any Queen.

In the case of the Queen, the player is required to “order” the suit that will be most convenient for him to continue the game. The opponent will have to cover the Queen with a card of the ordered suit or another Queen.

Some cards oblige the opponent to skip a turn and/or draw additional cards from the pack. This allows the player to build sometimes quite long chains and quickly get rid of cards. These cards include:
- all Aces (the opponent skips one turn);
- all Sevens (the opponent skips one turn and takes 1 card);
- all Sixes (the opponent skips one turn and takes 2 cards);
- King of Spades (opponent skips one turn and takes 5 cards);
- all Eights (the opponent skips the turn, but the player must cover the Eight using his cards or drawing cards from the pack, even if his own have already run out).
The rest of the cards after use require only the transition of the turn.

Penalty points are calculated as follows:
— each Six, Seven, Eight and Ten add their denomination to the sum;
— Jack adds 2 points, Queen – 3, King – 4, Ace – 11;
— Nines don’t affect the score.

Bonuses are calculated as follows:
— if a player exits the round by covering the card with the Queen of Spades, 40 points are deducted from his penalty;
— if the player goes out with any other Queen, 20 points are deducted.
For this reason, players’ scores can be negative</value>
  </data>
  <data name="BeginTheGame" xml:space="preserve">
    <value>&amp;Begin the game</value>
  </data>
  <data name="CardIsNotSuitable" xml:space="preserve">
    <value>The selected card is not suitable for the turn</value>
  </data>
  <data name="CardNotSelected" xml:space="preserve">
    <value>No card selected for turn</value>
  </data>
  <data name="CardValue_Ace" xml:space="preserve">
    <value>A</value>
  </data>
  <data name="CardValue_Jack" xml:space="preserve">
    <value>J</value>
  </data>
  <data name="CardValue_King" xml:space="preserve">
    <value>K</value>
  </data>
  <data name="CardValue_Queen" xml:space="preserve">
    <value>Q</value>
  </data>
  <data name="EightShouldBeCovered" xml:space="preserve">
    <value>The eight needs to be covered</value>
  </data>
  <data name="FinishGame" xml:space="preserve">
    <value>Finish the game?</value>
  </data>
  <data name="GetHelp" xml:space="preserve">
    <value>&amp;Help</value>
  </data>
  <data name="LoseMessage" xml:space="preserve">
    <value>This game is lost</value>
  </data>
  <data name="LoseRoundMessage" xml:space="preserve">
    <value>You have lost this round</value>
  </data>
  <data name="OrderSuit" xml:space="preserve">
    <value>Order a suit</value>
  </data>
  <data name="PCScore" xml:space="preserve">
    <value>Computer: </value>
  </data>
  <data name="PlayerScore" xml:space="preserve">
    <value>Player: </value>
  </data>
  <data name="SkipTurn" xml:space="preserve">
    <value>&amp;Skip turn</value>
  </data>
  <data name="TakeCard" xml:space="preserve">
    <value>&amp;Take card</value>
  </data>
  <data name="WinMessage" xml:space="preserve">
    <value>YOU WON THIS GAME!!!</value>
  </data>
  <data name="WinRoundMessage" xml:space="preserve">
    <value>You have won this round!</value>
  </data>
</root>